// ScreenControl Database Schema
// https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & AUTHENTICATION
// ============================================

model User {
  id                      String    @id @default(cuid())
  email                   String    @unique
  emailVerified           DateTime?
  passwordHash            String?
  name                    String?
  image                   String?

  // Company/Billing info
  companyName             String?
  billingEmail            String?
  vatNumber               String?

  // Account status
  accountStatus           AccountStatus @default(PENDING_VERIFICATION)

  // Role (admin can manage all agents, user can only manage own)
  role                    UserRole  @default(USER)

  // Email verification
  emailVerificationToken  String?
  emailVerificationExpires DateTime?

  // Password reset
  passwordResetToken      String?
  passwordResetExpires    DateTime?

  // OAuth
  oauthProvider           String?   // 'google', 'github', 'local'
  oauthId                 String?

  // Timestamps
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt
  lastLogin               DateTime?

  // Relations
  accounts                Account[]
  sessions                Session[]
  licenses                License[]
  builds                  Build[]
  transactions            Transaction[]
  auditLogs               AuditLog[]
  vouchersCreated         VoucherCode[] @relation("VoucherCreator")
  ownedAgents             Agent[]       @relation("AgentOwner")
  installerDownloads      InstallerDownload[]
  activityPattern         CustomerActivityPattern?
  aiConnections           AIConnection[]

  // OAuth & Remote MCP
  oauthTokens             OAuthAccessToken[]
  oauthCodes              OAuthAuthorizationCode[]
  mcpConnections          McpConnection[]

  // Rescue tokens for boot USB pairing
  rescueTokens            RescueToken[]

  // Job scheduler
  scheduledJobs           ScheduledJob[]

  // Agent permissions locked by this user
  lockedAgents            Agent[]   @relation("AgentPermissionLocker")

  // File transfers initiated by this user
  fileTransfers           FileTransfer[]

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ============================================
// LICENSING
// ============================================

model License {
  id                  String        @id @default(cuid())
  userId              String
  licenseKey          String        @unique  // Format: SC-XXXX-XXXX-XXXX-XXXX
  productType         ProductType   @default(AGENT)
  maxConcurrentAgents Int           @default(1)

  // Validity
  status              LicenseStatus @default(ACTIVE)
  validFrom           DateTime      @default(now())
  validUntil          DateTime?

  // Trial tracking
  isTrial             Boolean       @default(true)
  trialStarted        DateTime?
  trialEnds           DateTime?

  // Timestamps
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt

  // Relations
  user                User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  agents              Agent[]
  transactions        Transaction[]

  @@map("licenses")
}

// ============================================
// AGENTS (Phone-Home Tracking)
// ============================================

model Agent {
  id                String      @id @default(cuid())
  licenseId         String
  agentKey          String      @unique  // Unique identifier for this agent instance

  // Ownership - which customer owns this agent
  ownerUserId       String?     // The SaaS customer who distributed the installer

  // Stamped installer info
  customerId        String?     // From stamped installer
  licenseUuid       String?     @unique  // Issued on activation
  installerVersion  String?     // Version of installer used

  // Machine identification
  machineId         String?     // Unique hardware ID
  machineFingerprint String     // SHA256 hash of hardware
  fingerprintRaw    Json?       // Raw fingerprint data for comparison

  // Machine info
  hostname          String?
  displayName       String?     // User-defined friendly name (e.g., "My MacBook", "Office PC")
  localUsername     String?
  osType            OSType      @default(MACOS)
  osVersion         String?
  agentVersion      String?
  arch              String?

  // Hardware details (for fingerprinting)
  cpuModel          String?
  diskSerial        String?
  motherboardUuid   String?

  // Status
  status            AgentStatus @default(OFFLINE)
  state             AgentState  @default(PENDING)
  powerState        PowerState  @default(ACTIVE)
  isScreenLocked    Boolean     @default(false)
  hasDisplay        Boolean     @default(true)  // False for headless servers
  currentTask       String?
  ipAddress         String?

  // Duplicate detection
  isDuplicate       Boolean     @default(false)
  duplicateOf       String?     // Points to original agent ID if duplicate

  // Debug/Testing
  isMock            Boolean     @default(false)  // True for mock agents created in debug mode

  // Browser settings
  defaultBrowser    BrowserType?  // Preferred browser for LLM tools (null = system default)

  // Timestamps
  firstSeenAt       DateTime    @default(now())
  lastSeenAt        DateTime    @default(now())
  lastActivity      DateTime    @default(now())
  activatedAt       DateTime?

  // Custom label
  label             String?
  groupName         String?
  tags              String[]

  // Agent secret for re-authentication after token expiry
  agentSecretHash   String?   // bcrypt hash of agent's API key

  // Server-controlled permissions (pushed via heartbeat)
  masterModeEnabled     Boolean   @default(false)  // Two-way STDIO enabled
  fileTransferEnabled   Boolean   @default(false)  // Can send/receive files
  localSettingsLocked   Boolean   @default(false)  // Lock tray/menu settings

  // Permission metadata
  permissionsLockedAt   DateTime?
  permissionsLockedById String?
  permissionsLockedBy   User?     @relation("AgentPermissionLocker", fields: [permissionsLockedById], references: [id], onDelete: SetNull)

  // Relations
  license           License     @relation(fields: [licenseId], references: [id], onDelete: Cascade)
  owner             User?       @relation("AgentOwner", fields: [ownerUserId], references: [id], onDelete: SetNull)
  sessions          AgentSession[]
  auditLogs         AuditLog[]
  fingerprintChanges FingerprintChange[]
  commandLogs       CommandLog[]
  transfersAsSource FileTransfer[] @relation("TransferSource")
  transfersAsDest   FileTransfer[] @relation("TransferDest")
  toolCapabilities  AgentToolCapability[]

  @@unique([customerId, machineId])
  @@index([ownerUserId])
  @@index([customerId])
  @@index([licenseUuid])
  @@index([state])
  @@index([powerState])
  @@map("agents")
}

// Track fingerprint changes for security audit
model FingerprintChange {
  id              String    @id @default(cuid())
  agentId         String
  changeType      String    // "ip_change", "hardware_change", "duplicate_detected"
  previousValue   String?
  newValue        String?
  actionTaken     String    // "allowed", "logged", "deactivated"
  details         Json?

  createdAt       DateTime  @default(now())

  agent           Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)

  @@index([agentId])
  @@index([changeType])
  @@map("fingerprint_changes")
}

// Customer activity patterns for smart power state management
model CustomerActivityPattern {
  id                String        @id @default(cuid())
  userId            String        @unique

  // Hourly activity counts (24 slots, 0-23)
  hourlyActivity    Int[]         @default([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])

  // Detected quiet hours
  quietHoursStart   Int?          // Hour (0-23)
  quietHoursEnd     Int?          // Hour (0-23)

  // Schedule configuration
  scheduleMode      ScheduleMode  @default(AUTO_DETECT)
  timezone          String        @default("UTC")

  updatedAt         DateTime      @updatedAt

  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("customer_activity_patterns")
}

// ============================================
// INSTALLER DOWNLOADS (tracking)
// ============================================

model InstallerDownload {
  id                String    @id @default(cuid())
  userId            String

  // What was downloaded
  platform          OSType
  variant           String?   // "gui", "headless", etc.
  version           String

  // Stamp info
  customerId        String    // The customer ID embedded in this installer
  checksumSalt      String?   // Random salt for anti-piracy checksum

  // Tracking
  ipAddress         String?
  userAgent         String?

  downloadedAt      DateTime  @default(now())

  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([customerId])
  @@map("installer_downloads")
}

// ============================================
// AI/LLM CONNECTIONS (tracking)
// ============================================

model AIConnection {
  id                String    @id @default(cuid())
  userId            String    // Which customer's AI is connecting

  // Connection info
  sessionId         String    @unique  // MCP session ID
  clientName        String?   // e.g., "Claude", "OpenWebUI", "Cursor"
  clientVersion     String?

  // Authorization
  isAuthorized      Boolean   @default(false)
  authorizedAt      DateTime?

  // Status
  isActive          Boolean   @default(true)
  lastActivityAt    DateTime  @default(now())

  // Target agent (if bound to specific agent)
  targetAgentId     String?

  // Connection tracking
  ipAddress         String?
  userAgent         String?

  createdAt         DateTime  @default(now())
  disconnectedAt    DateTime?

  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  commandLogs       CommandLog[]

  @@index([userId])
  @@index([sessionId])
  @@index([isActive])
  @@map("ai_connections")
}

// ============================================
// COMMAND LOGS (audit trail)
// ============================================

model CommandLog {
  id                String    @id @default(cuid())
  agentId           String
  aiConnectionId    String?

  // Command details
  method            String    // e.g., "tools/call", "screenshot", "click"
  params            Json?     // Command parameters
  toolName          String?   // For tools/call, the specific tool

  // Execution
  status            CommandStatus @default(PENDING)
  result            Json?     // Result or error
  errorMessage      String?

  // Timing
  startedAt         DateTime  @default(now())
  completedAt       DateTime?
  durationMs        Int?

  // Context
  ipAddress         String?

  agent             Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)
  aiConnection      AIConnection? @relation(fields: [aiConnectionId], references: [id], onDelete: SetNull)

  @@index([agentId])
  @@index([aiConnectionId])
  @@index([method])
  @@index([status])
  @@index([startedAt])
  @@map("command_logs")
}

model AgentSession {
  id              String    @id @default(cuid())
  agentId         String
  sessionStart    DateTime  @default(now())
  sessionEnd      DateTime?
  durationMinutes Int?

  // Connection info
  ipAddress       String?

  agent Agent @relation(fields: [agentId], references: [id], onDelete: Cascade)

  @@map("agent_sessions")
}

// ============================================
// BUILDS (Executable Patching)
// ============================================

model Build {
  id            String   @id @default(cuid())
  userId        String
  platform      Platform
  buildHash     String   // SHA256 of the build
  customerTag   String   // Embedded customer identifier

  // Download tracking
  downloadUrl   String?
  downloadCount Int      @default(0)
  checksum      String?  // SHA256 for integrity verification

  // Timestamps
  createdAt     DateTime @default(now())
  expiresAt     DateTime? // Download URL expiration

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("builds")
}

// ============================================
// PAYMENTS & TRANSACTIONS
// ============================================

model Transaction {
  id              String            @id @default(cuid())
  userId          String
  licenseId       String?

  // Stripe
  stripePaymentId String?
  stripeCustomerId String?
  stripeSubscriptionId String?

  // Amount
  amount          Int               // Amount in cents
  currency        String            @default("USD")

  // Details
  productType     ProductType
  status          TransactionStatus @default(PENDING)

  // Voucher
  voucherId       String?
  discountAmount  Int?              // Discount in cents

  // Timestamps
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  // Relations
  user            User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  license         License?          @relation(fields: [licenseId], references: [id])
  voucher         VoucherCode?      @relation(fields: [voucherId], references: [id])

  @@map("transactions")
}

model VoucherCode {
  id              String    @id @default(cuid())
  code            String    @unique

  // Discount
  discountPercent Int?      // e.g., 20 for 20%
  discountAmount  Int?      // Fixed amount in cents

  // Usage limits
  maxUses         Int?
  usedCount       Int       @default(0)
  maxUsesPerUser  Int       @default(1)

  // Validity
  validFrom       DateTime  @default(now())
  validUntil      DateTime?
  isActive        Boolean   @default(true)

  // Creator
  createdBy       String
  createdAt       DateTime  @default(now())

  // Relations
  creator         User      @relation("VoucherCreator", fields: [createdBy], references: [id])
  transactions    Transaction[]

  @@map("voucher_codes")
}

// ============================================
// AUDIT LOG
// ============================================

model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  agentId   String?

  action    String   // e.g., 'login', 'agent_heartbeat', 'license_activated'
  details   Json?    // Additional context
  ipAddress String?
  userAgent String?

  timestamp DateTime @default(now())

  // Relations
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  agent     Agent?   @relation(fields: [agentId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([agentId])
  @@index([action])
  @@index([timestamp])
  @@map("audit_logs")
}

// ============================================
// OAUTH - Dynamic Client Registration (RFC 7591)
// ============================================

model OAuthClient {
  id                  String    @id @default(cuid())
  clientId            String    @unique  // Public identifier (UUID)
  clientSecretHash    String?             // Hashed, only for confidential clients
  clientName          String              // "Claude", "Cursor", "Claude Code"
  clientUri           String?             // Homepage of client

  // Registration
  redirectUris        String[]            // Allowed callback URLs
  grantTypes          String[]  @default(["authorization_code", "refresh_token"])
  responseTypes       String[]  @default(["code"])
  tokenEndpointAuth   String    @default("none") // "none" for public clients

  // Metadata
  logoUri             String?
  contacts            String[]  @default([])

  // Tracking
  registeredByIp      String?
  registeredByAgent   String?             // User-Agent header

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Relations
  tokens              OAuthAccessToken[]
  authCodes           OAuthAuthorizationCode[]
  mcpConnection       McpConnection?

  @@index([clientId])
  @@map("oauth_clients")
}

// ============================================
// OAUTH - Authorization Codes
// ============================================

model OAuthAuthorizationCode {
  id                  String    @id @default(cuid())
  code                String    @unique  // Hashed authorization code

  // PKCE (required)
  codeChallenge       String
  codeChallengeMethod String    @default("S256")

  // Request context
  redirectUri         String              // Must match on token exchange
  scope               String[]            // Requested scopes
  resource            String              // The tenant MCP URL (audience)
  state               String?             // Client state parameter

  // Relations
  clientId            String
  client              OAuthClient @relation(fields: [clientId], references: [id], onDelete: Cascade)
  userId              String
  user                User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Lifecycle
  expiresAt           DateTime            // Short-lived (10 minutes)
  usedAt              DateTime?           // Set when exchanged for token

  createdAt           DateTime  @default(now())

  @@index([code])
  @@index([clientId])
  @@index([userId])
  @@map("oauth_authorization_codes")
}

// ============================================
// OAUTH - Access & Refresh Tokens
// ============================================

model OAuthAccessToken {
  id                  String    @id @default(cuid())
  accessTokenHash     String    @unique   // SHA256 hash of token
  refreshTokenHash    String?   @unique   // SHA256 hash of refresh token
  tokenType           String    @default("Bearer")

  // Scopes & audience
  scope               String[]            // Granted scopes
  audience            String              // The tenant MCP URL this token is for

  // Expiry
  accessExpiresAt     DateTime            // Short-lived (1 hour)
  refreshExpiresAt    DateTime?           // Longer-lived (30 days)

  // Relations
  clientId            String
  client              OAuthClient @relation(fields: [clientId], references: [id], onDelete: Cascade)
  userId              String
  user                User @relation(fields: [userId], references: [id], onDelete: Cascade)
  connectionId        String
  connection          McpConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  // Revocation
  revokedAt           DateTime?
  revokedReason       String?

  createdAt           DateTime  @default(now())
  lastUsedAt          DateTime?

  @@index([accessTokenHash])
  @@index([refreshTokenHash])
  @@index([clientId])
  @@index([userId])
  @@index([connectionId])
  @@map("oauth_access_tokens")
}

// ============================================
// MCP CONNECTIONS - Per-User Endpoint Management
// ============================================

model McpConnection {
  id                  String    @id @default(cuid())
  userId              String

  // Endpoint identifier (the UUID in /mcp/{uuid})
  endpointUuid        String    @unique @default(cuid())

  // Connection metadata
  name                String              // User-friendly name: "My Claude Desktop"
  description         String?

  // Which client is using this (populated after first auth)
  clientName          String?             // "Claude", "Cursor", etc.
  connectedClientId   String?             // OAuth client ID (legacy field)

  // OAuth client for this connection (auto-created with connection)
  oauthClientId       String?   @unique
  oauthClient         OAuthClient? @relation(fields: [oauthClientId], references: [id])

  // Status
  status              McpConnectionStatus @default(ACTIVE)

  // Usage tracking
  lastUsedAt          DateTime?
  totalRequests       Int       @default(0)

  // Timestamps
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  revokedAt           DateTime?

  // Relations
  user                User @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokens              OAuthAccessToken[]
  requestLogs         McpRequestLog[]

  @@index([userId])
  @@index([endpointUuid])
  @@index([status])
  @@map("mcp_connections")
}

// ============================================
// MCP REQUEST LOGGING
// ============================================

model McpRequestLog {
  id                  String    @id @default(cuid())
  connectionId        String

  // Request details
  method              String              // "tools/list", "tools/call", etc.
  toolName            String?             // For tools/call
  params              Json?

  // Response
  success             Boolean
  errorCode           Int?
  errorMessage        String?
  durationMs          Int?

  // Context
  ipAddress           String?
  userAgent           String?

  createdAt           DateTime  @default(now())

  connection          McpConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@index([connectionId])
  @@index([method])
  @@index([createdAt])
  @@map("mcp_request_logs")
}

// ============================================
// ENUMS
// ============================================

enum McpConnectionStatus {
  ACTIVE              // Can be used
  PAUSED              // Temporarily disabled
  REVOKED             // Permanently disabled
}

enum AccountStatus {
  ACTIVE
  PENDING_VERIFICATION
  SUSPENDED
  DELETED
}

enum UserRole {
  USER          // Can manage own agents only
  ADMIN         // Can manage all agents
}

enum LicenseStatus {
  ACTIVE
  EXPIRED
  SUSPENDED
  CANCELLED
}

enum AgentStatus {
  ONLINE
  OFFLINE
  SUSPENDED
}

enum AgentState {
  PENDING   // Not activated
  ACTIVE    // Billable
  BLOCKED   // Blocked by customer
  EXPIRED   // License expired
}

enum PowerState {
  ACTIVE    // 5-10s heartbeat - portal or AI actively using
  PASSIVE   // 30-60s heartbeat - normal idle state
  SLEEP     // 5-10min heartbeat - quiet hours
}

enum OSType {
  WINDOWS
  MACOS
  LINUX
}

enum BrowserType {
  SYSTEM    // Use system default browser
  CHROME
  FIREFOX
  SAFARI
  EDGE
}

enum ScheduleMode {
  ALWAYS_ACTIVE     // Never sleep
  AUTO_DETECT       // Learn from activity patterns
  CUSTOM            // User-defined quiet hours
  SLEEP_OVERNIGHT   // Simple overnight sleep (11pm-7am)
}

enum ProductType {
  AGENT
  HUB
  BUNDLE
}

enum Platform {
  WINDOWS
  MACOS
  LINUX
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}

enum CommandStatus {
  PENDING     // Waiting to be sent
  SENT        // Sent to agent
  EXECUTING   // Agent acknowledged, running
  COMPLETED   // Successfully completed
  FAILED      // Failed with error
  TIMEOUT     // Timed out
  CANCELLED   // Cancelled before completion
}

enum FileTransferStatus {
  PENDING
  TRANSFERRING
  COMPLETED
  FAILED
  CANCELLED
}

// ============================================
// FILE TRANSFER
// ============================================

model FileTransfer {
  id                String   @id @default(cuid())
  transferId        String   @unique  // Unique identifier for this transfer

  sourceAgentId     String?
  destAgentId       String?
  initiatorUserId   String

  fileName          String
  sourcePath        String
  destPath          String?
  fileSize          BigInt

  status            FileTransferStatus @default(PENDING)
  bytesTransferred  BigInt   @default(0)

  errorMessage      String?
  createdAt         DateTime @default(now())
  completedAt       DateTime?

  sourceAgent       Agent?   @relation("TransferSource", fields: [sourceAgentId], references: [id], onDelete: SetNull)
  destAgent         Agent?   @relation("TransferDest", fields: [destAgentId], references: [id], onDelete: SetNull)
  initiator         User     @relation(fields: [initiatorUserId], references: [id], onDelete: Cascade)

  @@index([sourceAgentId])
  @@index([destAgentId])
  @@index([initiatorUserId])
  @@index([status])
  @@map("file_transfers")
}

// ============================================
// AUTO-UPDATE SYSTEM
// ============================================

// Track available agent versions
model AgentVersion {
  id              String    @id @default(cuid())
  version         String    @unique  // Semantic version: "1.2.3"
  channel         UpdateChannel @default(STABLE)

  // Release info
  releaseNotes    String?   @db.Text
  releaseDate     DateTime  @default(now())

  // Platform builds
  builds          AgentBuild[]

  // Rollout control
  isActive        Boolean   @default(true)
  rolloutPercent  Int       @default(100)  // Gradual rollout: 0-100

  // Minimum version required (for forced updates)
  minVersion      String?   // Agents below this must update

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([version])
  @@index([channel])
  @@map("agent_versions")
}

// Platform-specific builds
model AgentBuild {
  id              String    @id @default(cuid())
  versionId       String
  platform        Platform
  arch            String    // "x64", "arm64"

  // File info
  filename        String
  fileSize        Int       // bytes
  sha256          String    // For integrity verification

  // Download tracking
  downloadCount   Int       @default(0)

  // Storage path (relative to builds directory)
  storagePath     String

  createdAt       DateTime  @default(now())

  version         AgentVersion @relation(fields: [versionId], references: [id], onDelete: Cascade)

  @@unique([versionId, platform, arch])
  @@index([platform, arch])
  @@map("agent_builds")
}

// Per-agent update settings (optional, defaults to global)
model AgentUpdateSettings {
  id              String    @id @default(cuid())
  agentId         String    @unique

  // Update preferences
  updateMode      UpdateMode @default(AUTO)
  channel         UpdateChannel @default(STABLE)

  // Scheduling
  scheduledTime   DateTime?  // For SCHEDULED mode
  quietHoursStart Int?       // Hour (0-23)
  quietHoursEnd   Int?       // Hour (0-23)

  // Status
  pendingVersion  String?    // Downloaded but not installed
  lastCheckAt     DateTime?
  lastUpdateAt    DateTime?

  updatedAt       DateTime   @updatedAt

  @@map("agent_update_settings")
}

enum UpdateChannel {
  STABLE
  BETA
  DEV
}

enum UpdateMode {
  AUTO        // Download and install automatically
  DOWNLOAD    // Auto-download, manual install
  MANUAL      // Manual check and install
  SCHEDULED   // Install at scheduled time
  DISABLED    // No updates
}

// ============================================
// RESCUE TOKENS (for boot USB pairing)
// ============================================

model RescueToken {
  id              String    @id @default(cuid())
  userId          String

  // Token for pairing (format: xxxx-xxxx-xxxx-xxxx)
  token           String    @unique

  // Metadata
  name            String?   // Optional name for this token
  description     String?

  // Usage limits
  maxUses         Int       @default(10)  // How many rescue systems can use this
  usedCount       Int       @default(0)

  // Validity
  expiresAt       DateTime?              // Optional expiration
  isActive        Boolean   @default(true)

  // Timestamps
  createdAt       DateTime  @default(now())
  lastUsedAt      DateTime?

  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@map("rescue_tokens")
}

// ============================================
// EMAIL AGENT - AI-Triggered Email Tasks
// ============================================

model EmailTask {
  id              String          @id @default(cuid())

  // Email details
  emailUid        Int             // IMAP UID for reference
  messageId       String?         // Email Message-ID header
  fromAddress     String          // Sender email
  fromName        String?         // Sender display name
  toAddresses     String[]        // Recipients
  subject         String
  body            String          @db.Text  // Plain text body
  receivedAt      DateTime

  // Attachments stored separately
  attachments     EmailAttachment[]

  // Processing
  status          EmailTaskStatus @default(PENDING)
  priority        Int             @default(0)  // Higher = more urgent

  // LLM Analysis
  llmProvider     String?         // Which LLM processed this
  llmModel        String?         // Model used
  llmAnalysis     String?         @db.Text  // LLM's interpretation
  llmActions      Json?           // Structured actions to take

  // Execution
  targetAgentId   String?         // Agent to execute on (if determined)
  executionLog    String?         @db.Text  // Log of actions taken
  errorMessage    String?

  // Response
  responseSent    Boolean         @default(false)
  responseBody    String?         @db.Text

  // Timing
  createdAt       DateTime        @default(now())
  processedAt     DateTime?       // When LLM analyzed it
  executedAt      DateTime?       // When actions were executed
  completedAt     DateTime?       // When fully done (including response)

  @@index([status])
  @@index([fromAddress])
  @@index([createdAt])
  @@map("email_tasks")
}

model EmailAttachment {
  id              String          @id @default(cuid())
  taskId          String
  filename        String
  contentType     String
  size            Int
  storagePath     String?         // Path if saved to disk

  task            EmailTask       @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@index([taskId])
  @@map("email_attachments")
}

model EmailAgentSettings {
  id              String          @id @default(cuid())

  // IMAP Configuration
  imapHost        String
  imapPort        Int             @default(143)
  imapUser        String
  imapPassword    String          // Encrypted
  imapTls         Boolean         @default(false)
  imapMailbox     String          @default("INBOX")

  // LLM Configuration
  llmProvider     String          @default("vllm")  // vllm, claude, openai, claude-code, claude-code-managed
  llmBaseUrl      String?         // For vLLM/local
  llmApiKey       String?         // Encrypted
  llmModel        String?

  // Supervisor LLM Configuration (for managed claude-code mode)
  supervisorProvider  String?     // vllm, claude, openai (defaults to vllm)
  supervisorBaseUrl   String?     // Supervisor LLM base URL
  supervisorApiKey    String?     // Supervisor LLM API key
  supervisorModel     String?     // Supervisor LLM model

  // Behavior
  isEnabled       Boolean         @default(false)
  processInterval Int             @default(60)  // Seconds between checks
  autoReply       Boolean         @default(true)

  // Reply SMTP Configuration (separate from main email server)
  replySmtpHost   String?         // e.g., 192.168.10.6
  replySmtpPort   Int             @default(25)
  replySmtpUser   String?         // Usually null for local relay
  replySmtpPass   String?         // Usually null for local relay
  replySmtpTls    Boolean         @default(false)
  replyFromEmail  String?         // From address for replies
  replyFromName   String          @default("ScreenControl AI")

  // Allowed senders (empty = allow all)
  allowedSenders  String[]

  // System prompt for LLM
  systemPrompt    String?         @db.Text

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@map("email_agent_settings")
}

enum EmailTaskStatus {
  PENDING         // Waiting to be processed
  ANALYZING       // LLM is analyzing
  READY           // Analysis done, ready for execution
  EXECUTING       // Actions being executed
  AWAITING_REPLY  // Waiting for user input (future)
  COMPLETED       // Successfully completed
  FAILED          // Failed with error
  SKIPPED         // Skipped (e.g., spam, not actionable)
}

// ============================================
// JOB SCHEDULER
// ============================================

model JobType {
  id              String      @id @default(cuid())
  name            String      @unique  // "docker_health", "disk_cleanup", etc.
  displayName     String               // "Docker Health Check"
  description     String?
  category        JobCategory @default(CUSTOM)

  // Default prompt/instructions for AI
  defaultPrompt   String      @db.Text

  // Default tasks checklist (JSON array of strings)
  defaultTasks    Json?

  // Whether this is a system-provided template
  isSystem        Boolean     @default(false)

  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  scheduledJobs   ScheduledJob[]

  @@map("job_types")
}

model ScheduledJob {
  id              String      @id @default(cuid())
  userId          String
  jobTypeId       String?

  name            String
  description     String?

  // Schedule (cron format)
  cronExpression  String               // "0 2 * * *" = daily 2am
  timezone        String      @default("UTC")

  // Target agents
  targetAgentIds  String[]             // Which agents to run on
  runParallel     Boolean     @default(true)

  // Custom prompt (overrides/extends job type)
  customPrompt    String?     @db.Text

  // Notifications
  notifyEmail     String?
  notifyOn        NotifyCondition @default(ISSUES)

  // Status
  isEnabled       Boolean     @default(true)
  nextRunAt       DateTime?
  lastRunAt       DateTime?

  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  // Relations
  user            User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  jobType         JobType?    @relation(fields: [jobTypeId], references: [id], onDelete: SetNull)
  runs            JobRun[]

  @@index([userId])
  @@index([isEnabled, nextRunAt])
  @@map("scheduled_jobs")
}

model JobRun {
  id              String        @id @default(cuid())
  scheduledJobId  String

  // Execution
  status          JobRunStatus  @default(PENDING)
  triggeredBy     JobTrigger    @default(SCHEDULE)

  // Timing
  startedAt       DateTime      @default(now())
  completedAt     DateTime?

  // Aggregate results
  totalAgents     Int           @default(0)
  successCount    Int           @default(0)
  failureCount    Int           @default(0)
  issuesFound     Int           @default(0)

  // Relations
  scheduledJob    ScheduledJob  @relation(fields: [scheduledJobId], references: [id], onDelete: Cascade)
  results         JobRunResult[]

  @@index([scheduledJobId])
  @@index([startedAt])
  @@map("job_runs")
}

model JobRunResult {
  id              String          @id @default(cuid())
  jobRunId        String
  agentId         String

  // Execution
  status          JobResultStatus @default(PENDING)
  startedAt       DateTime?
  completedAt     DateTime?

  // AI output
  output          String?         @db.Text   // Full AI response
  summary         String?                    // Brief summary
  issuesFound     Json?                      // Array of issues
  actionsTaken    Json?                      // Array of actions

  // Error tracking
  errorMessage    String?

  // Relations
  jobRun          JobRun          @relation(fields: [jobRunId], references: [id], onDelete: Cascade)

  @@index([jobRunId])
  @@index([agentId])
  @@map("job_run_results")
}

enum JobCategory {
  HEALTH          // Health checks
  MAINTENANCE     // Regular maintenance
  SECURITY        // Security scans
  BACKUP          // Backup tasks
  CUSTOM          // User-defined
}

enum NotifyCondition {
  ALWAYS          // Always send notification
  ISSUES          // Only when issues found
  FAILURE         // Only on failures
  NEVER           // Never notify
}

enum JobRunStatus {
  PENDING         // Waiting to start
  RUNNING         // In progress
  COMPLETED       // Finished successfully
  PARTIAL         // Some agents failed
  FAILED          // All failed
  CANCELLED       // Cancelled by user
}

enum JobResultStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
  SKIPPED         // Agent offline
}

enum JobTrigger {
  SCHEDULE        // Cron triggered
  MANUAL          // User triggered
  ALERT           // Triggered by another system
  EMAIL           // Triggered via email
}

// ============================================
// TERMINAL SESSION TOKENS
// ============================================

model TerminalSessionToken {
  id              String    @id @default(cuid())
  token           String    @unique
  agentId         String
  userId          String
  remoteAddress   String
  expiresAt       DateTime
  createdAt       DateTime  @default(now())

  @@index([token])
  @@index([expiresAt])
  @@map("terminal_session_tokens")
}

// ============================================
// MCP TOOL DEFINITIONS
// ============================================

// Canonical tool definition - the "what" of a tool
model ToolDefinition {
  id              String    @id @default(cuid())
  name            String    @unique  // e.g., "screenshot", "click", "shell_exec"
  category        ToolCategory
  isEnabled       Boolean   @default(true)  // Global enable/disable
  sortOrder       Int       @default(0)     // For UI ordering

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  platformVariants  ToolPlatformVariant[]
  agentCapabilities AgentToolCapability[]

  @@index([category])
  @@index([isEnabled])
  @@map("tool_definitions")
}

// Platform-specific tool variant - the "how" for each OS
model ToolPlatformVariant {
  id              String    @id @default(cuid())
  toolId          String
  platform        OSType    // WINDOWS, MACOS, LINUX

  // MCP tool definition fields
  description     String    @db.Text  // Platform-specific description
  inputSchema     Json      // JSON Schema for tool parameters

  // Platform-specific directives for LLM
  directives      String?   @db.Text  // Extra instructions for this platform

  // Availability
  isAvailable     Boolean   @default(true)  // Is this tool available on this platform?
  requiresDisplay Boolean   @default(false) // Requires GUI (not headless)
  requiresBrowser Boolean   @default(false) // Requires browser extension

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  tool            ToolDefinition @relation(fields: [toolId], references: [id], onDelete: Cascade)

  @@unique([toolId, platform])
  @@index([platform])
  @@map("tool_platform_variants")
}

// Agent's tool capabilities - which tools an agent supports
model AgentToolCapability {
  id              String    @id @default(cuid())
  agentId         String
  toolId          String

  // Override availability for this specific agent
  isEnabled       Boolean   @default(true)

  // Timestamps
  reportedAt      DateTime  @default(now())  // When agent last reported this capability

  // Relations
  agent           Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)
  tool            ToolDefinition @relation(fields: [toolId], references: [id], onDelete: Cascade)

  @@unique([agentId, toolId])
  @@index([agentId])
  @@index([toolId])
  @@map("agent_tool_capabilities")
}

enum ToolCategory {
  APPLICATION     // App management (launch, focus, close)
  SCREEN          // Screenshots, screen capture
  INPUT           // Mouse, keyboard, clicks
  FILESYSTEM      // File operations
  SYSTEM          // System info, processes
  SHELL           // Command execution
  CLIPBOARD       // Clipboard operations
  BROWSER         // Browser automation
  NETWORK         // Network operations
  UI_INSPECTION   // UI element inspection
}
